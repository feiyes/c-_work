关于模板的一些说明：

模板原理：
编译器并不是把函数模板处理成能处理任意类的函数，而是通过具体类型由函数模板产生特定的函数．编译器会对函数模板进行两次编译，１．在模板声明的地方对模板本身进行编译，２．在调用的地方对由具体参数替换后的代码进行编译．

使用要求：
１．参数类型严格匹配，不存在隐式转化
２．需先实例化模板，才能调用相应的模板
３．函数模板只适用于，函数名相同，参数个数相同，而参数类型不相同的场景．

注意：
１．对于类外实现友元，需做类前声明对应的友元函数，并在类中友元函数前加上<>
２．模板类必须把定义和实现放在同一个.h/.hpp文件里
　在分离式编译情况下，编译器编译某一个.cpp文件的时并不知道另一个.cpp文件的存在，也不会去查找(当遇到未决符号时，它会寄希望与链接器)．这种模式在没有模板的情况下，运行良好．但遇到模板时会出现问题，因为模板仅在需要的时候才会具体化出来，所以当编译器只看到模板声明的时候，它不能具体化模板，只能创建一个具有外部链接的符号，并期待链接器能够将符号的地址决议出来．然而当实现该模板的.cpp文件没有用到模板的具体实现时，编译器懒得去具现，所以，整个工程的.obj中就找不到模板具现体的二进制代码，于是链接器也黔驴技穷．
  通过使用包含模式，使得编程时方便的访问所需的类型定义，避免了来自链接器的未定义的错误．
